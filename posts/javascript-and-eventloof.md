---
title: "자바스크립트와 이벤트루프"
date: "2021-10-18"
tags: ["#javascript"]
thumbnailImgPath: "/javascript-and-eventloof/eventloof.png"
thumbnail: "이벤트루프는 왜 필요하고 어떻게 작동할까?"
---

최근 면접을 자주보며 이벤트 루프에 대한 질문에 답해야하는 상황이 많이 있었다. 한심하게도 프론트 영역에 발을 디딘지도 거의 3년이되어가는데 생각처럼 명확하고 깔끔하게 답변하지 못했다. 이번기회에 완벽하게 정리해 보려고 한다.

# 이벤트 루프는 왜 필요 할까?

자바스크립트는 싱글 스레드 언어이기 때문이다. 스레드가 하나라는 의미는 한번에 하나의 일만 처리 할 수 있다(동시에 2가지 이상의 함수(태스크)를 실행 할 수 없다.)는 의미이다. 하지만 자바스크립트를 보면 동시에 여러가지 일을 처리 하는것 처럼 보인다. 애니메이션 효과가 적용되면서 이벤트를 처리하기도하고 HTTP 요청을하면서 렌더링을 하기도 한다. 이런 자바스크립트의 동시성을 지원하는 것이 바로 이벤트 루프다.

# 동기와 비동기

![synchronous](https://blog.kakaocdn.net/dn/bztSy0/btqCz451jcO/1UjnGAajLPDoBmh3VqNRjK/img.jpg)

동기와 비동기를 이해하기 위해 다음 코드를 보자.

## 동기 방식

```javascript
function sleep(func, delay) {
  const delayUntill = Date.now() + delay;

  while (Date.now() < delayUntill);

  func();
}

function foo() {
  console.log("foo");
}

function bar() {
  console.log("bar");
}

sleep(foo, 3 * 1000);
bar();

// 3초 경과 후 foo 호출 -> bar 호출
```

sleep 함수는 3초 후에 foo 함수를 실행 시키고 그 다음 bar 함수가 호출된다. 이때 bar 함수는 sleep 함수의 호출이 종료된 이후 호출되므로 3초동안 블로킹(작업중단)이 된다.

이처럼 현재 실행중인 테스크가 종료 될때 까지 다음에 실행될 태스크가 대기하는 방식을 **동기 처리** 라고 한다. 동기 처리 방식은 태스크를 순서대로 하나씩 실행하기 때문에 실행 순서가 보장되는 장점은 있지만 태스크가 종료될때까지 다음 태스크가 블로킹되는 단점이있다.

다음 위의 예제를 비동기 방식으로 바꿔보자.

## 비동기 방식

```javascript
function foo() {
  console.log("foo");
}

function bar() {
  console.log("bar");
}

setTimeout(foo, 3 * 1000);
bar();

// bar 호출 -> 3초 경과 후 foo 호출
```

동기 방식과 비슷하게 3초 후 foo 함수를 호출하지만 setTimeout 이후의 태스크를 블로킹하지 않고(Non-Bloking) 곧바로 실행한다. 이처럼 현재 진행중인 태스크를 기다리지 않고 다음 태스크가 실행되는 방식을 **비동기 처리** 라고 한다. 비동기 처리 방식은 코드 실행 순서를 보장하지 않는다는 단점이 있다.

# 이벤트 루프

![eventloof](https://miro.medium.com/max/2048/1*4lHHyfEhVB0LnQ3HlhSs8g.png)

먼저 자바스크립트 엔진에 대한 이해가 필요하다 자바스크립트 엔진은 크게 네부분으로 나뉜다.

1. 콜 스택
2. 힙
3. 태스크 큐
4. 이벤트 루프

## 콜 스택(Call Stack)

실행컨텍스트가 생성되고 추가되는 부분이 콜 스택이다. 함수를 호출하면 함수 순차적으로 콜 스택에 푸시되고 가장 나중에 푸시된 함수가 먼저 실행되는 선입후출(FILO) 구조이다. 자바스크립트 엔진은 하나의 콜스택만 가지고 있기 때문에 실행중인 함수가 종료되기 전 까진 다른 어떤 태스크도 실행되지 않는다.

## 힙(Heap)

힙은 자바스크립트 객체가 저장되는 메모리 공간이다. 실행컨텍스트는 힙에 있는 메모리를 참조한다.
메모리에 값을 저장할려면 해당 값의 크기를 알아야한다 그런데 객체는 원시값과 달리 크기가 정해져 있지 않으므로 런타임에 결정(동적 할당) 해야한다. 따라서 힙은 구조화 되어있지않다는 특징이 있다.

## 태스크 큐

Timeout 이나 AJAX 와 같은 비동기 함수의 콜백 또는 이벤트 핸들러가 일시적으로 보관되는 장소다.

## 이벤트 루프

콜 스택에 현재 실행중인 태스크가 없으면 태스크 큐에 대기 중인 함수(콜백, 이벤트 핸들러)가 있는지 반복해서 확인 후 실행중인 태스크가 없다면 콜 스택으로 태스크를 이동시킨다.

자바스크립트 개발자라면 한번쯤은 공부해본 그림이다. 간단하게 순서를 정리하면,

## 태스크 실행 순서

다음의 예제가 실행되는 순서를 정확하게 분석해보자.

```javascript
function foo() {
  console.log("foo");
}

function bar() {
  console.log("bar");
}

setTimeout(foo, 0);
bar();
```

1. 전역 코드가 평가되고 전역 실행 컨텍스트가 생기며 콜 스택에 푸시된다.
2. 전역 코드가 실행되기 시작하고 setTimeout 함수가 호출된다.
3. setTimeout 함수가 실행되면 콜백 함수를 호출스케줄링하고 종료되어 콜 스택에서 팝된다. 타이머 설정과 타이머가 완료됐을때 콜백함수를 태스크 큐로 푸시하는 것은 브라우저의 역할이다.
4. 브라우저는 타이머를 설정하고 타이머가 완료되면 콜백함수 foo 를 태스크 큐에 푸시한다. 예제의 경우 지연시간이 0ms 지만 지연시간이 4ms 이하인 경우 최소 지연시간 4ms 가 지정된다. **따라서 4ms 후에 콜백함수가 태스크 큐에 푸시된다.**
5. bar 함수가 호출되어 실행되고 콜 스택에서 팝된다. **foo 함수는 태스크 큐에서 아직 대기중이다.**
6. 전역 코드 실행이 종료되고 콜 스택에서 팝된다.
7. 이벤트 루프에 의해 콜 스택이 비어있음을 감지하고 태스크 큐에서 대기 중인 foo 함수르 콜 스택에 푸시한다. 이후 함수가 실행되고 콜 스택에서 팝된다.
8. 요약하면 이렇다.

9. 모든 비동기 API들은 작업이 완료되면 콜백 함수를 태스크 큐에 추가한다.
10. 이벤트 루프는 '현재 실행중인 태스크가 없을 때'(주로 호출 스택이 비워졌을 때) 태스크 큐의 첫 번째 태스크를 꺼내와 실행한다.
